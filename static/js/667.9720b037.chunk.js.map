{"version":3,"file":"static/js/667.9720b037.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/create fake namespace object","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","core/models.ts","core/core-logic.ts","core/date-utils.ts","core/functions.ts","workers/simulationWorker.ts"],"sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"107\":\"ce040c18\",\"851\":\"035746e7\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/mmr-strategy/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t667: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkmmr_strategy_react\"] = self[\"webpackChunkmmr_strategy_react\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","export interface Simulation {\n  portfolioSnapshots: PortfolioSnapshot[];\n  rebalanceLogs: RebalanceLog[];\n  variables: Variables;\n  annualizedTQQQRate?: number;\n  annualizedQQQRate?: number;\n  annualizedStrategyRate?: number;\n}\n\nexport interface Variables {\n  initialMoney: number;\n  startDate: string;\n  endDate: string;\n  rebalanceDays: number;\n  targetRate: number;\n  cashDayRate: number;\n  targetRatio: number;\n  dropRate: number;\n  monthlyNewCash: number;\n}\n\nexport interface PortfolioSnapshot {\n  date: string;\n  investments: Investments;\n  cumulativeRateSinceRebalance: number;\n  nextTarget: number;\n  peak: number;\n  pullback: number;\n  lastRebalanceDate: string;\n  nextRebalanceDate: string;\n}\n\nexport interface RebalanceLog {\n  date: string;\n  before: PortfolioSnapshot;\n  after: PortfolioSnapshot;\n  cumulativeRateSinceLastRebalance: number;\n  rebalanceType: RebalanceType;\n}\n\nexport enum RebalanceType {\n  BigSpike = \"Big Spike\",\n  Spike = \"Spike\",\n  Excess = \"Excess\",\n  Shortfall = \"Shortfall\",\n  Drop = \"Drop\",\n  BigDrop = \"Big Drop\",\n}\n\nexport const RebalanceTypeExplanation = {\n  \"Big Spike\": \"Rebalance with 1.5x factor, usually big spikes comes together\",\n  \"Spike\": \"Rebalance with 1x factor, basically just restart\",\n  \"Excess\": \"Sell excess TQQQ to follow the target rate\",\n  \"Shortfall\": \"Buy more TQQQ to follow the target rate\",\n  \"Drop\": \"No action taken, maintain current allocation, we don't sell low\",\n  \"Big Drop\": \"Rebalance with 0.5x factor, now market is very low, we have to buy something\",\n};\n\nexport interface Investments {\n  total: number;\n  mockTotalQQQ: number;\n  mockTotalTQQQ: number;\n  TQQQ: number;\n  cash: number;\n  ratio: number;\n}\n\nexport interface MarketData {\n  QQQ: Record<string, number>;\n  TQQQ: Record<string, number>;\n}\n\nexport interface ChartPoint {\n  time: string;\n  value: number;\n}\n\nexport type ChartData = ChartPoint[];\n\nexport type MultiSeriesChartData = Record<string, ChartData>;\n","import { addDaysToDate, deepCopyPortfolioSnapshot } from \"./functions\";\nimport { Investments, MarketData, PortfolioSnapshot, RebalanceLog, RebalanceType, Simulation } from \"./models\";\n\nexport const computePortfolioSnapshot = (simulation: Simulation, date: string, marketData: MarketData) => {\n  const lastInvestmentsSnapshot = simulation.portfolioSnapshots[simulation.portfolioSnapshots.length - 1];\n  const newPortfolioSnapshot = deepCopyPortfolioSnapshot(lastInvestmentsSnapshot);\n\n  const TQQQDelta = marketData.TQQQ[date] || 0;\n  const QQQDelta = marketData.QQQ[date] || 0;\n\n  const newTQQQ = lastInvestmentsSnapshot.investments.TQQQ * (TQQQDelta / 100 + 1);\n  const newCash = lastInvestmentsSnapshot.investments.cash * (1 + simulation.variables.cashDayRate);\n  const newTotal = newTQQQ + newCash;\n  const investments: Investments = {\n    total: newTotal,\n    TQQQ: newTQQQ,\n    cash: newCash,\n    ratio: newTQQQ / (newTQQQ + newCash),\n    mockTotalQQQ: lastInvestmentsSnapshot.investments.mockTotalQQQ * (QQQDelta / 100 + 1),\n    mockTotalTQQQ: lastInvestmentsSnapshot.investments.mockTotalTQQQ * (TQQQDelta / 100 + 1),\n  };\n\n  newPortfolioSnapshot.date = date;\n  newPortfolioSnapshot.investments = investments;\n  newPortfolioSnapshot.peak = Math.max(lastInvestmentsSnapshot.peak, newTotal);\n  newPortfolioSnapshot.pullback = -(newPortfolioSnapshot.peak - newTotal) / newPortfolioSnapshot.peak;\n  newPortfolioSnapshot.cumulativeRateSinceRebalance =\n    (1 + newPortfolioSnapshot.cumulativeRateSinceRebalance) * (1 + TQQQDelta / 100) - 1;\n\n  return newPortfolioSnapshot;\n};\n\nexport const rebalance = (before: PortfolioSnapshot, simulation: Simulation, marketData: MarketData) => {\n  const { monthlyNewCash, rebalanceDays, targetRatio, targetRate, dropRate } = simulation.variables;\n\n  before.investments.cash += (monthlyNewCash / 30) * rebalanceDays;\n  before.investments.mockTotalQQQ += (monthlyNewCash / 30) * rebalanceDays;\n  before.investments.mockTotalTQQQ += (monthlyNewCash / 30) * rebalanceDays;\n  before.investments.total = before.investments.cash + before.investments.TQQQ;\n  before.investments.ratio = before.investments.TQQQ / before.investments.total;\n\n  const after = deepCopyPortfolioSnapshot(before);\n\n  const doubleTargetRate = targetRate * 2;\n  const doubleDropRate = dropRate * 2;\n  const cumulativeRate = before.cumulativeRateSinceRebalance;\n\n  const isBigSpike = cumulativeRate >= doubleTargetRate;\n  const isSpike = cumulativeRate < doubleTargetRate && cumulativeRate >= targetRate;\n  const isExcess = cumulativeRate < targetRate && before.investments.total >= before.nextTarget;\n  const isShortfall = before.investments.total < before.nextTarget && cumulativeRate >= dropRate;\n  const isDrop = cumulativeRate < dropRate && cumulativeRate >= doubleDropRate;\n  const isBigDrop = cumulativeRate < doubleDropRate;\n\n  let rebalanceType: RebalanceType = RebalanceType.Excess;\n\n  if (isBigSpike) {\n    rebalanceType = RebalanceType.BigSpike;\n    after.investments.TQQQ = before.investments.total * Math.min(targetRatio * 1.5, 1);\n    after.investments.cash = before.investments.total * (1 - Math.min(targetRatio * 1.5, 1));\n    after.investments.total = before.investments.total;\n    after.investments.ratio = after.investments.TQQQ / after.investments.total;\n    after.nextTarget = before.investments.total * (1 + targetRate * 1.5);\n  } else if (isSpike) {\n    rebalanceType = RebalanceType.Spike;\n    after.investments.TQQQ = before.investments.total * targetRatio * 1;\n    after.investments.cash = before.investments.total * (1 - targetRatio * 1);\n    after.investments.total = before.investments.total;\n    after.investments.ratio = after.investments.TQQQ / after.investments.total;\n    after.nextTarget = before.investments.total * (1 + targetRate * 1);\n  } else if (isExcess) {\n    rebalanceType = RebalanceType.Excess;\n    const excess = before.investments.total - before.nextTarget;\n    const actualExcess = Math.min(excess, before.investments.TQQQ);\n    after.investments.TQQQ = before.investments.TQQQ - actualExcess;\n    after.investments.cash = before.investments.cash + actualExcess;\n    after.investments.total = before.investments.total;\n    after.investments.ratio = after.investments.TQQQ / after.investments.total;\n    after.nextTarget = before.nextTarget * (1 + targetRate);\n  } else if (isShortfall) {\n    rebalanceType = RebalanceType.Shortfall;\n    const shortfall = before.nextTarget - before.investments.total;\n    const actualShortfall = Math.min(shortfall, before.investments.cash);\n    after.investments.TQQQ = before.investments.TQQQ + actualShortfall;\n    after.investments.cash = before.investments.cash - actualShortfall;\n    after.investments.total = before.investments.total;\n    after.investments.ratio = after.investments.TQQQ / after.investments.total;\n    after.nextTarget = before.nextTarget * (1 + targetRate);\n  } else if (isDrop) {\n    rebalanceType = RebalanceType.Drop;\n  } else if (isBigDrop) {\n    rebalanceType = RebalanceType.BigDrop;\n    after.investments.TQQQ = before.investments.total * targetRatio * 0.75;\n    after.investments.cash = before.investments.total * (1 - targetRatio * 0.75);\n    after.investments.total = before.investments.total;\n    after.investments.ratio = after.investments.TQQQ / after.investments.total;\n    after.nextTarget = before.investments.total * (1 + targetRate * 0.75);\n  } else {\n    console.log(\"bug\");\n  }\n\n  after.nextRebalanceDate = addDaysToDate(before.date, rebalanceDays);\n  after.cumulativeRateSinceRebalance = 0;\n\n  const rebalanceLog: RebalanceLog = {\n    date: before.date,\n    before: before,\n    after: after,\n    cumulativeRateSinceLastRebalance: cumulativeRate,\n    rebalanceType: rebalanceType,\n  };\n  // console.log(rebalanceLog);\n  simulation.rebalanceLogs.push(rebalanceLog);\n\n  return after;\n};\n","/**\n * Simple date utilities that work consistently with YYYY-MM-DD strings\n * All dates are treated as local dates for simplicity\n */\n\n/**\n * Formats a Date object to YYYY-MM-DD string in local timezone\n */\nexport const formatDate = (date: Date): string => {\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n};\n\n/**\n * Parses a YYYY-MM-DD string to a Date object in local timezone\n */\nexport const parseDate = (dateString: string): Date => {\n  if (!dateString || typeof dateString !== 'string') {\n    throw new Error(`Invalid date string: ${dateString}`);\n  }\n\n  const parts = dateString.split('-');\n  if (parts.length !== 3) {\n    throw new Error(`Invalid date format. Expected YYYY-MM-DD, got: ${dateString}`);\n  }\n\n  const [year, month, day] = parts.map(Number);\n  if (isNaN(year) || isNaN(month) || isNaN(day)) {\n    throw new Error(`Invalid date components in: ${dateString}`);\n  }\n\n  // Create date in local timezone\n  return new Date(year, month - 1, day);\n};\n\n/**\n * Adds days to a date string and returns a new date string\n */\nexport const addDays = (dateString: string, days: number): string => {\n  const date = parseDate(dateString);\n  date.setDate(date.getDate() + days);\n  return formatDate(date);\n};\n\n/**\n * Calculates the difference in days between two date strings\n */\nexport const daysBetween = (startDate: string, endDate: string): number => {\n  const start = parseDate(startDate);\n  const end = parseDate(endDate);\n  const diffTime = end.getTime() - start.getTime();\n  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n};\n\n/**\n * Calculates the difference in years between two date strings\n */\nexport const yearsBetween = (startDate: string, endDate: string): number => {\n  const start = parseDate(startDate);\n  const end = parseDate(endDate);\n  const diffTime = end.getTime() - start.getTime();\n  return diffTime / (1000 * 60 * 60 * 24 * 365.25);\n};\n\n/**\n * Adds years to a date string and returns a new date string\n */\nexport const addYears = (dateString: string, years: number): string => {\n  const date = parseDate(dateString);\n  date.setFullYear(date.getFullYear() + years);\n  return formatDate(date);\n};\n\n/**\n * Gets today's date as YYYY-MM-DD string\n */\nexport const today = (): string => {\n  return formatDate(new Date());\n};\n\n/**\n * Checks if a date string is valid\n */\nexport const isValidDate = (dateString: string): boolean => {\n  try {\n    parseDate(dateString);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Compares two date strings\n * Returns: -1 if date1 < date2, 0 if equal, 1 if date1 > date2\n */\nexport const compareDates = (date1: string, date2: string): number => {\n  if (date1 === date2) return 0;\n  return date1 < date2 ? -1 : 1;\n};\n","import { computePortfolioSnapshot, rebalance } from \"./core-logic\";\nimport {\n  Investments,\n  MarketData,\n  PortfolioSnapshot,\n  RebalanceLog,\n  RebalanceType,\n  Simulation,\n  Variables,\n} from \"./models\";\nimport { addDays, yearsBetween, addYears, today } from \"./date-utils\";\n\nexport const loadData = async (\n  setDataLoading: (loading: boolean) => void,\n  setMarketData: (data: MarketData | null) => void\n) => {\n  try {\n    setDataLoading(true);\n    setMarketData({\n      QQQ: (await import(\"../data/QQQ.json\")).default,\n      TQQQ: (await import(\"../data/TQQQ.json\")).default,\n    });\n  } catch (error) {\n    console.error(\"Error loading data:\", error);\n  } finally {\n    setDataLoading(false);\n  }\n};\n\nexport const setupInitialPortfolio = (simulation: Simulation, marketData: MarketData) => {\n  const investments: Investments = {\n    total: simulation.variables.initialMoney,\n    TQQQ: simulation.variables.initialMoney * simulation.variables.targetRatio,\n    cash: simulation.variables.initialMoney * (1 - simulation.variables.targetRatio),\n    ratio: simulation.variables.targetRatio,\n    mockTotalQQQ: simulation.variables.initialMoney,\n    mockTotalTQQQ: simulation.variables.initialMoney,\n  };\n\n  const firstValidDate = Object.keys(marketData.TQQQ).find((date) => date >= simulation.variables.startDate);\n\n  if (!firstValidDate) {\n    throw new Error(`No market data found for start date ${simulation.variables.startDate} or later`);\n  }\n\n  simulation.variables.startDate = firstValidDate;\n\n  const portfolioSnapshot: PortfolioSnapshot = {\n    date: firstValidDate,\n    investments: investments,\n    cumulativeRateSinceRebalance: 0,\n    nextTarget: simulation.variables.initialMoney * (1 + simulation.variables.targetRate),\n    peak: simulation.variables.initialMoney,\n    pullback: 0,\n    lastRebalanceDate: firstValidDate,\n    nextRebalanceDate: addDays(firstValidDate, simulation.variables.rebalanceDays),\n  };\n\n  simulation.portfolioSnapshots = [portfolioSnapshot];\n\n  const rebalanceLog: RebalanceLog = {\n    date: firstValidDate,\n    before: portfolioSnapshot,\n    after: portfolioSnapshot,\n    cumulativeRateSinceLastRebalance: 0,\n    rebalanceType: RebalanceType.Excess,\n  };\n  simulation.rebalanceLogs = [rebalanceLog];\n};\n\nexport const startSimulation = (\n  simulation: Simulation,\n  setSimulation: (simulation: Simulation) => void,\n  marketData: MarketData\n) => {\n  const result = runSingleSimulation(simulation, marketData);\n  setSimulation(result);\n};\n\n/**\n * Runs a single simulation with the given parameters\n * @param simulation - The simulation configuration\n * @param marketData - The market data\n * @param endDate - Optional end date to limit the simulation (format: YYYY-MM-DD)\n * @returns The completed simulation\n */\nexport const runSingleSimulation = (simulation: Simulation, marketData: MarketData): Simulation => {\n  // Create a deep copy of the simulation to avoid mutations\n  const newSimulation: Simulation = {\n    ...simulation,\n    portfolioSnapshots: [],\n    rebalanceLogs: [],\n    variables: { ...simulation.variables },\n  };\n\n  setupInitialPortfolio(newSimulation, marketData);\n\n  // Pre-allocate arrays to avoid frequent reallocations\n  const marketEntries = Object.entries(marketData.TQQQ);\n  let processedCount = 0;\n\n  for (const [date] of marketEntries) {\n    if (date <= newSimulation.variables.startDate) continue;\n    if (date > newSimulation.variables.endDate) break;\n\n    const portfolioSnapshot = computePortfolioSnapshot(newSimulation, date, marketData);\n\n    if (date >= portfolioSnapshot.nextRebalanceDate) {\n      const rebalancedSnapshot = rebalance(portfolioSnapshot, newSimulation, marketData);\n      newSimulation.portfolioSnapshots.push(rebalancedSnapshot);\n    } else {\n      newSimulation.portfolioSnapshots.push(portfolioSnapshot);\n    }\n\n    processedCount++;\n    \n    // Yield control periodically for very long simulations\n    if (processedCount % 1000 === 0) {\n      // Allow garbage collection for large datasets\n      if (global.gc) {\n        global.gc();\n      }\n    }\n  }\n\n  // Final rebalance and calculate rates\n  if (newSimulation.portfolioSnapshots.length > 0) {\n    const lastSnapshot = newSimulation.portfolioSnapshots[newSimulation.portfolioSnapshots.length - 1];\n    rebalance(lastSnapshot, newSimulation, marketData);\n    calculateAnnualizedRates(newSimulation);\n  }\n\n  return newSimulation;\n};\n\nexport const calculateAnnualizedRates = (simulation: Simulation) => {\n  const endDate = simulation.portfolioSnapshots[simulation.portfolioSnapshots.length - 1].date;\n\n  simulation.annualizedStrategyRate = calculateAnnualizedRate(\n    simulation.variables.initialMoney,\n    simulation.portfolioSnapshots[simulation.portfolioSnapshots.length - 1].investments.total,\n    simulation.variables.startDate,\n    endDate\n  );\n  simulation.annualizedQQQRate = calculateAnnualizedRate(\n    simulation.variables.initialMoney,\n    simulation.portfolioSnapshots[simulation.portfolioSnapshots.length - 1].investments.mockTotalQQQ,\n    simulation.variables.startDate,\n    endDate\n  );\n  simulation.annualizedTQQQRate = calculateAnnualizedRate(\n    simulation.variables.initialMoney,\n    simulation.portfolioSnapshots[simulation.portfolioSnapshots.length - 1].investments.mockTotalTQQQ,\n    simulation.variables.startDate,\n    endDate\n  );\n};\n\nexport const addDaysToDate = addDays;\n\n/**\n * Creates a deep copy of a PortfolioSnapshot object\n * @param snapshot - The PortfolioSnapshot to copy\n * @returns A new PortfolioSnapshot with all nested objects copied\n */\nexport const deepCopyPortfolioSnapshot = (snapshot: PortfolioSnapshot): PortfolioSnapshot => {\n  return {\n    ...snapshot,\n    investments: {\n      ...snapshot.investments,\n    },\n  };\n};\n\nexport const calculateAnnualizedRate = (\n  initial: number,\n  end: number,\n  initialDateString: string,\n  endDateString: string\n): number => {\n  const nbYears = yearsBetween(initialDateString, endDateString);\n\n  // Ensure we have at least some time period to avoid division by zero\n  if (nbYears <= 0) {\n    return 0;\n  }\n\n  return (end / initial) ** (1 / nbYears) - 1;\n};\n\nexport const convertAnnualRateToDaily = (annualRate: number): number => {\n  return Math.pow(1 + annualRate, 1 / 365) - 1;\n};\n\n/**\n * Runs multiple simulations starting every 10 days from 2000-01-01 to today\n * @param variables - The simulation variables (including initialMoney and all required fields)\n * @param marketData - The market data containing QQQ and TQQQ prices\n * @param nbYear - Number of years to run each simulation (default: 5)\n * @param onProgress - Optional callback to report progress (0-100)\n * @param signal - Optional AbortSignal to cancel the simulation\n * @returns Object containing array of simulation results with their starting dates and analysis results\n */\nexport const runMultipleSimulations = async (\n  variables: Variables,\n  marketData: MarketData,\n  nbYear: number,\n  onProgress?: (progress: number) => void,\n  signal?: AbortSignal\n): Promise<{\n  results: Array<{ startDate: string; simulation: Simulation }>;\n  analysisResults: any;\n}> => {\n  const results: Array<{ startDate: string; simulation: Simulation }> = [];\n\n  // Get all available dates from market data (sorted)\n  const availableDates = Object.keys(marketData.TQQQ).sort();\n  const firstAvailableDate = availableDates[0];\n  const lastAvailableDate = availableDates[availableDates.length - 1];\n\n  // Start from the first available date or 2000-01-01, whichever is later\n  const startDate = firstAvailableDate >= \"2000-01-01\" ? firstAvailableDate : \"2000-01-01\";\n  const todayString = today();\n\n  // End 3 years before the last available date to ensure we have enough data\n  const endDate = addYears(lastAvailableDate, -1);\n  const finalDate = endDate < todayString ? endDate : todayString;\n\n  // Calculate total number of days to process for progress tracking\n  const totalDays = Math.ceil((new Date(finalDate).getTime() - new Date(startDate).getTime()) / (1000 * 60 * 60 * 24));\n\n  let currentDateString = startDate;\n  let simulationCount = 0;\n  let loopIterations = 0;\n\n  // Memory monitoring\n  let lastMemoryCheck = Date.now();\n  const checkMemoryUsage = () => {\n    if (typeof performance !== 'undefined' && (performance as any).memory) {\n      const memory = (performance as any).memory;\n      if (memory.usedJSHeapSize > memory.jsHeapSizeLimit * 0.9) {\n        console.warn('High memory usage detected, forcing garbage collection');\n        if (global.gc) {\n          global.gc();\n        }\n      }\n    }\n  };\n\n  while (currentDateString <= finalDate) {\n    // Check for cancellation\n    if (signal?.aborted) {\n      const abortError = new Error('Simulation cancelled');\n      abortError.name = 'AbortError';\n      throw abortError;\n    }\n\n    // Memory check every 5 seconds\n    const now = Date.now();\n    if (now - lastMemoryCheck > 5000) {\n      checkMemoryUsage();\n      lastMemoryCheck = now;\n    }\n\n    const currentIterationDate = currentDateString;\n    loopIterations++;\n\n    // Check if this date exists in market data or find next available date\n    const nextAvailableDate = availableDates.find((date) => date >= currentIterationDate);\n\n    if (nextAvailableDate) {\n      try {\n        // Check if we have at least 30 days of data after the start date\n        const minEndDate = addDays(nextAvailableDate, 30);\n        const hasEnoughData = lastAvailableDate >= minEndDate;\n\n        if (hasEnoughData) {\n          // Calculate end date for this simulation\n          const simulationEndDateString = addYears(nextAvailableDate, nbYear);\n\n          // Create simulation configuration\n          const simulation: Simulation = {\n            portfolioSnapshots: [],\n            rebalanceLogs: [],\n            variables: {\n              ...variables,\n              startDate: nextAvailableDate,\n              endDate: simulationEndDateString,\n            },\n          };\n\n          // Run the simulation using the shared simulation logic\n          const completedSimulation = runSingleSimulation(simulation, marketData);\n\n          if (completedSimulation.portfolioSnapshots.length > 0) {\n            results.push({\n              startDate: nextAvailableDate,\n              simulation: completedSimulation,\n            });\n\n            simulationCount++;\n          }\n        }\n      } catch (error) {\n        // Re-throw abort errors\n        if (error instanceof Error && error.name === 'AbortError') {\n          throw error;\n        }\n        console.warn(`Simulation failed for start date ${nextAvailableDate}:`, error);\n      }\n    }\n\n    // Move to next date (3 days later)\n    currentDateString = addDays(currentDateString, 1);\n    \n    // Report progress and yield control back to the browser less frequently to reduce overhead\n    if (loopIterations % 50 === 0) {\n      const progress = Math.min(100, (loopIterations / totalDays) * 100);\n      onProgress?.(Math.round(progress));\n      await new Promise(resolve => requestAnimationFrame(() => setTimeout(resolve, 0)));\n    }\n  }\n\n  console.log(\n    `Completed ${simulationCount} simulations from ${results[0]?.startDate} to ${\n      results[results.length - 1]?.startDate\n    }`\n  );\n\n  // Report 100% completion\n  onProgress?.(100);\n\n  const analysisResults = analyzeSimulationResults(results);\n\n  // Clear the large results array to free memory, keeping only what we need\n  results.length = 0;\n\n  return { results: [], analysisResults };\n};\n/**\n * Analyzes multiple simulation results to get statistics\n * @param results - Array of simulation results from runMultipleSimulations\n * @returns Statistics about the simulation results and the detailed results data\n */\nexport const analyzeSimulationResults = (results: Array<{ startDate: string; simulation: Simulation }>) => {\n  if (results.length === 0) {\n    return {\n      totalSimulations: 0,\n      averageStrategyRate: 0,\n      averageQQQRate: 0,\n      averageTQQQRate: 0,\n      bestStrategyRate: 0,\n      worstStrategyRate: 0,\n      winRate: 0,\n      resultsWithRates: [],\n    };\n  }\n\n  const strategyRates = results.map((r) => r.simulation.annualizedStrategyRate || 0);\n  const qqqRates = results.map((r) => r.simulation.annualizedQQQRate || 0);\n  const tqqqRates = results.map((r) => r.simulation.annualizedTQQQRate || 0);\n\n  const averageStrategyRate = strategyRates.reduce((sum, rate) => sum + rate, 0) / strategyRates.length;\n  const averageQQQRate = qqqRates.reduce((sum, rate) => sum + rate, 0) / qqqRates.length;\n  const averageTQQQRate = tqqqRates.reduce((sum, rate) => sum + rate, 0) / tqqqRates.length;\n\n  const bestStrategyRate = Math.max(...strategyRates);\n  const worstStrategyRate = Math.min(...strategyRates);\n\n  // Calculate how much better strategy is than QQQ\n  const strategyVsQQQPercentageImprovement = (averageStrategyRate / averageQQQRate - 1) * 100;\n  // Count how many times strategy beats QQQ\n  const strategyWinsOverQQQ = results.filter(\n    (r) => (r.simulation.annualizedStrategyRate || 0) > (r.simulation.annualizedQQQRate || 0)\n  ).length;\n  const winRateVsQQQ = (strategyWinsOverQQQ / results.length) * 100;\n\n  // // Calculate how much better strategy is than QQQ\n  // const TQQQVsQQQPercentageImprovement = (averageTQQQRate / averageQQQRate - 1) * 100;\n  // // Count how many times strategy beats QQQ\n  // const TQQQWinsOverQQQ = results.filter(\n  //   (r) => (r.simulation.annualizedTQQQRate || 0) > (r.simulation.annualizedQQQRate || 0)\n  // ).length;\n  // const winRateTQQQVsQQQ = (TQQQWinsOverQQQ / results.length) * 100;\n\n  const resultsWithRates = results.map((r) => ({\n    startDate: r.startDate,\n    strategyRate: r.simulation.annualizedStrategyRate || 0,\n    qqqRate: r.simulation.annualizedQQQRate || 0,\n    tqqqRate: r.simulation.annualizedTQQQRate || 0,\n  }));\n\n  console.log(\"Absolute worst 10\");\n  resultsWithRates\n    .sort((a, b) => a.strategyRate - b.strategyRate)\n    .slice(0, 10)\n    .forEach((result, index) => {\n      console.log(\n        `${index + 1}. ${result.startDate}: Strategy= ${(result.strategyRate * 100)?.toFixed(2)}%, QQQ= ${(\n          result.qqqRate * 100\n        )?.toFixed(2)}%, TQQQ= ${(result.tqqqRate * 100)?.toFixed(2)}%`\n      );\n    });\n\n  console.log(\"Relative worst 10\");\n  resultsWithRates\n    .sort((a, b) => a.strategyRate - a.qqqRate - (b.strategyRate - b.qqqRate))\n    .slice(0, 10)\n    .forEach((result, index) => {\n      console.log(\n        `${index + 1}. ${result.startDate}: Strategy= ${(result.strategyRate * 100)?.toFixed(2)}%, QQQ= ${(\n          result.qqqRate * 100\n        )?.toFixed(2)}%, TQQQ= ${(result.tqqqRate * 100)?.toFixed(2)}%`\n      );\n    });\n\n  console.log(\n    \"\\naverageStrategyRate\\t\\t\\t\\t\",\n    `${(averageStrategyRate * 100).toFixed(2)}%`,\n    \"\\nstrategyVsQQQImprovement\\t\\t\\t\\t\",\n    `${strategyVsQQQPercentageImprovement.toFixed(2)}%`,\n    \"\\nwinRateVsQQQ\\t\\t\\t\\t\",\n    `${winRateVsQQQ.toFixed(2)}%`,\n    `absoluteWorst`,\n    resultsWithRates.sort((a, b) => a.strategyRate - b.strategyRate)[0].strategyRate.toFixed(2) + \"%\",\n    `relativeWorst`,\n    resultsWithRates\n      .sort((a, b) => a.strategyRate - a.qqqRate - (b.strategyRate - b.qqqRate))[0]\n      .strategyRate.toFixed(2) + \"%\"\n  );\n\n  return {\n    totalSimulations: results.length,\n    averageStrategyRate,\n    averageQQQRate,\n    averageTQQQRate,\n    bestStrategyRate,\n    worstStrategyRate,\n    dateRange: {\n      start: results[0]?.startDate,\n      end: results[results.length - 1]?.startDate,\n    },\n    resultsWithRates,\n  };\n};\n\nexport const formatValue = (value: number, isPercentage = false): string => {\n  if (typeof value !== \"number\") return \"\";\n\n  // Format ratios and pullbacks as percentages\n  if (isPercentage) {\n    return (value * 100).toFixed(2) + \"%\";\n  }\n\n  // Format currency values\n  return new Intl.NumberFormat(\"en-US\", {\n    style: \"currency\",\n    currency: \"USD\",\n    minimumFractionDigits: 0,\n    maximumFractionDigits: 0,\n  }).format(value);\n};\n","// Web Worker for running simulations in a separate thread\n// This can be implemented if we need even better UI responsiveness\n\nimport { runMultipleSimulations } from '../core/functions';\nimport { Variables, MarketData } from '../core/models';\n\ninterface SimulationWorkerMessage {\n  type: 'RUN_SIMULATIONS' | 'CANCEL_SIMULATION';\n  variables?: Variables;\n  marketData?: MarketData;\n  nbYear?: number;\n}\n\ninterface SimulationWorkerResponse {\n  type: 'SIMULATION_COMPLETE' | 'SIMULATION_ERROR' | 'SIMULATION_PROGRESS' | 'SIMULATION_CANCELLED';\n  results?: any;\n  error?: string;\n  progress?: number;\n}\n\n// Declare the worker context with proper typing\ndeclare const self: Worker & {\n  addEventListener: (type: string, listener: (event: MessageEvent) => void) => void;\n  postMessage: (message: any) => void;\n};\n\n// Global abort controller for cancellation\nlet abortController: AbortController | null = null;\n\n// Handle messages from the main thread\nself.addEventListener('message', async (e: MessageEvent<SimulationWorkerMessage>) => {\n  const { type, variables, marketData, nbYear } = e.data;\n  \n  if (type === 'CANCEL_SIMULATION') {\n    // Cancel any running simulation\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n      self.postMessage({\n        type: 'SIMULATION_CANCELLED'\n      } as SimulationWorkerResponse);\n    }\n    return;\n  }\n  \n  if (type === 'RUN_SIMULATIONS' && variables && marketData && nbYear) {\n    // Cancel any existing simulation first\n    if (abortController) {\n      abortController.abort();\n    }\n    \n    // Create new abort controller\n    abortController = new AbortController();\n    \n    try {\n      // Progress callback to report back to main thread\n      const onProgress = (progress: number) => {\n        self.postMessage({\n          type: 'SIMULATION_PROGRESS',\n          progress\n        } as SimulationWorkerResponse);\n      };\n\n      const results = await runMultipleSimulations(\n        variables, \n        marketData, \n        nbYear, \n        onProgress,\n        abortController.signal\n      );\n      \n      // Only send results if not cancelled\n      if (!abortController.signal.aborted) {\n        self.postMessage({\n          type: 'SIMULATION_COMPLETE',\n          results\n        } as SimulationWorkerResponse);\n      }\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        // Cancelled simulation - send cancellation message\n        self.postMessage({\n          type: 'SIMULATION_CANCELLED'\n        } as SimulationWorkerResponse);\n      } else {\n        self.postMessage({\n          type: 'SIMULATION_ERROR',\n          error: error instanceof Error ? error.message : 'Unknown error'\n        } as SimulationWorkerResponse);\n      }\n    } finally {\n      abortController = null;\n    }\n  }\n});\n\nexport {};\n"],"names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","leafPrototypes","getProto","Object","getPrototypeOf","obj","t","value","mode","this","__esModule","then","ns","create","r","def","current","indexOf","getOwnPropertyNames","forEach","key","d","definition","o","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","miniCssF","g","globalThis","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","p","installedChunks","i","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","push","bind","data","chunkIds","moreModules","runtime","length","pop","RebalanceType","computePortfolioSnapshot","simulation","date","marketData","lastInvestmentsSnapshot","portfolioSnapshots","newPortfolioSnapshot","deepCopyPortfolioSnapshot","TQQQDelta","TQQQ","QQQDelta","QQQ","newTQQQ","investments","newCash","cash","variables","cashDayRate","newTotal","total","ratio","mockTotalQQQ","mockTotalTQQQ","peak","Math","max","pullback","cumulativeRateSinceRebalance","rebalance","before","monthlyNewCash","rebalanceDays","targetRatio","targetRate","dropRate","after","doubleTargetRate","doubleDropRate","cumulativeRate","isBigSpike","isSpike","isExcess","nextTarget","isShortfall","isDrop","isBigDrop","rebalanceType","Excess","BigSpike","min","Spike","excess","actualExcess","Shortfall","shortfall","actualShortfall","Drop","BigDrop","console","log","nextRebalanceDate","addDaysToDate","rebalanceLog","cumulativeRateSinceLastRebalance","rebalanceLogs","formatDate","getFullYear","String","getMonth","padStart","getDate","parseDate","dateString","Error","parts","split","year","month","day","map","Number","isNaN","Date","addDays","days","setDate","addYears","years","setFullYear","runSingleSimulation","newSimulation","setupInitialPortfolio","initialMoney","firstValidDate","find","startDate","portfolioSnapshot","lastRebalanceDate","marketEntries","entries","processedCount","endDate","rebalancedSnapshot","global","gc","lastSnapshot","calculateAnnualizedRates","annualizedStrategyRate","calculateAnnualizedRate","annualizedQQQRate","annualizedTQQQRate","snapshot","initial","end","initialDateString","endDateString","nbYears","yearsBetween","start","getTime","runMultipleSimulations","async","nbYear","onProgress","signal","_results$","_results","results","availableDates","sort","firstAvailableDate","lastAvailableDate","todayString","finalDate","totalDays","ceil","currentDateString","simulationCount","loopIterations","lastMemoryCheck","now","checkMemoryUsage","performance","memory","usedJSHeapSize","jsHeapSizeLimit","warn","aborted","abortError","name","currentIterationDate","nextAvailableDate","minEndDate","simulationEndDateString","completedSimulation","error","progress","round","resolve","requestAnimationFrame","setTimeout","analysisResults","analyzeSimulationResults","_results$2","_results2","totalSimulations","averageStrategyRate","averageQQQRate","averageTQQQRate","bestStrategyRate","worstStrategyRate","winRate","resultsWithRates","strategyRates","qqqRates","tqqqRates","sum","rate","strategyVsQQQPercentageImprovement","winRateVsQQQ","filter","strategyRate","qqqRate","tqqqRate","a","b","slice","result","index","_ref","_ref2","_ref3","toFixed","_ref4","_ref5","_ref6","dateRange","abortController","addEventListener","type","abort","AbortController","postMessage","message"],"sourceRoot":""}